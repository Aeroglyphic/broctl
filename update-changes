#! /usr/bin/env bash
#
# Assembles a draft CHANGES entry out of recent commits. The entry is prepended
# to the current CHANGES file and the user then gets a chance to further edit
# the it in the editor before it gets committed.

changes=CHANGES

tmp=${changes}.tmp
trap "rm -f $tmp" EXIT

version=`git describe $rev 2>/dev/null | sed 's/^v//g' | sed "s/-[^-]*$//g"`

if [ "$version" == "" ]; then
    echo "can't generate version string"
    exit 1
fi

# Get the last revision for which we recorded entries.
last=`cat $changes | egrep '^[0-9].* \| [a-z0-9]+ *$' | head -1`

echo

if [ "$last" == "" ]; then
    echo "Warning: cannot find previous entry, assuming all is new ..."
else
    echo "New revisions since version" $last
fi

echo

last_hash=`echo $last | awk '{print $(NF)}'`

rm -f $tmp
printf '%s | ' $version >$tmp
git show -s "--pretty=tformat:%ci | %H" master >>$tmp

found=0

for rev in `git rev-list --date-order --no-merges master ^${last_hash}`; do
   git show -s "--pretty=format:  %H | %aN | %s%n" $rev | cat

   author=`git show -s "--pretty=format:%aN" $rev`
   msg=`git show -s "--pretty=format:%B" $rev`

   if [ "$msg" != "" ]; then
       ( echo -n "$msg"; printf " (%s)" "$author" ) | awk 'NR==1{printf "  * %s\n", $0; next }{printf "    %s\n", $0}' >>$tmp
       echo >>$tmp
       found=1
   fi

done

if [ "$found" == "0" ]; then
    echo "  None."
    echo
    exit 0
fi

cat $changes >>$tmp

echo
echo Type Enter to edit new $changes, or CTRL-C to abort without changes. 
read
eval $EDITOR $tmp

rm -f $changes.bak
mv $tmp $changes

echo "Old $tmp in saved in ${changes}.bak."

git add $changes
git commit -e -m "Updating $changes."
