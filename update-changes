#! /usr/bin/env bash
#
# Assembles a draft CHANGES entry out of recent commits. The entry is prepended
# to the current CHANGES file and the user then gets a chance to further edit
# the it in the editor before it gets committed. Also updates the VERSION file.

changes=CHANGES
version=VERSION

tmp=${changes}.tmp
trap "rm -f $tmp" EXIT

version_short=`git describe $rev 2>/dev/null | sed 's/^v//g' | sed "s/-[^-]*$//g"`
version_full=`git describe $rev 2>/dev/null  | sed 's/^v//g'`

if [ "$version_short" == "" ]; then
    echo "can't generate version_short string"
    exit 1
fi

# Get the last revision for which we recorded entries.
last=`cat $changes | egrep '^[0-9].* \| [a-z0-9]+ *$' | head -1`

echo

if [ "$last" == "" ]; then
    echo "Warning: cannot find previous entry, assuming all is new ..."
else
    echo "New revisions since version_short" $last
fi

echo

last_hash=`echo $last | awk '{print $(NF)}'`

rm -f $tmp
printf '%s | ' $version_short >$tmp
git show -s "--pretty=tformat:%ci | %H" master >>$tmp
echo >>$tmp

found=0

for rev in `git rev-list --date-order --no-merges master ^${last_hash}`; do
   git show -s "--pretty=format:  %H | %aN | %s%n" $rev | cat

   author=`git show -s "--pretty=format:%aN" $rev`
   msg=`git show -s "--pretty=format:%B" $rev`

   if [ "$msg" != "" ]; then
       ( echo -n "$msg"; printf " (%s)" "$author" ) | awk 'NR==1{printf "  * %s\n", $0; next }{printf "    %s\n", $0}' >>$tmp
       echo >>$tmp
       found=1
   fi

done

if [ "$found" == "0" ]; then
    echo "  None."
    echo
    exit 0
fi

cat $changes >>$tmp

echo
echo Type Enter to edit new $changes, or CTRL-C to abort without changes. 
read
eval $EDITOR $tmp

rm -f $changes.bak
mv $tmp $changes
echo $version_full >$version

git add $changes $version
git commit --amend

echo "Old $tmp in saved in ${changes}.bak."
echo "Set $version to $version_full."

